import  dirTree   from 'directory-tree';
import { resolve } from 'path';
import { watch }  from 'chokidar';
import { Server } from 'unete-io';
import { spawn } from 'child_process';
import { Observable } from 'rxjs';
import { log, cold, danger, highlight } from 'termx';


export default function Serve (FOLDER, PORT, config: { verbose?: any, include: Array<string>, exclude: Array<string> } = { include: [], exclude: [] }) {
    if(!config.verbose) config.verbose = { emit: true, error: true, logs: true };
    
    const verbose = config.verbose;
    const print = log;
    const Functions = {}
    
    //? -------- File Watchers ---------
    
    const paths = plainifyTree(dirTree(FOLDER).children).filter(p => {
        for(const r of config.include) {
            const regex = new RegExp(r, "i");

            if(regex.test(p)) return true;
        }

        return false;
    }).filter(p => {
        for(const r of config.exclude) {
            const regex = new RegExp(r, "i");

            if(regex.test(p)) return false;
        }

        return true;
    });
    
    function normalizeName (child) {
        child.name = child.name.replace(/-([a-z])/gi, ($0, $1) => $1.toUpperCase())
    
        if(child.type === "directory")
            return child.name[0].toUpperCase() + child.name.substring(1);
        else {
            return child.name
                        .replace(/^(.+)\..+$/, ($0, $1) => $1)
                        .replace(/[^a-z0-9\$]/gi, "")
        }
    }
    
    function plainifyTree (children, prefix="") {
        let paths = [];
        
        for(const child of children) {
            const pref = prefix? `${prefix}/${child.name}` : child.name;
    
            if(child.type === "file")
                paths.push(pref);
            else if(child.type === "directory" && child.children.length)
                paths.push(...plainifyTree(child.children, pref));
        }
    
        return paths;
    }
    
    //? --------- Definitions ----------
    
    function readData (str) {
        if(!isNaN(+str)) return +str;
        try {
            return JSON.parse(str);
        } catch (exc) {}
    
        return str;
    }
    
    function addFile (path) {
        const paths = path.split('/');
        let   pointer = Functions;
    
        for(let i=0;i<paths.length-1;i++) {
            const name = normalizeName({ name: paths[i], type: "directory" })
            if(!pointer[name])
                pointer[name] = {};
    
            pointer = pointer[name];
        }
    
        pointer[normalizeName({ name: paths[paths.length - 1], type: "file" })] = function exec (...args) {
            //* Data value emission
            return new Observable(subscriber => {
    
                const Events = {
                    emit (value) {
                        subscriber.next(value);
                    }
                };
    
    
                function parse (str) {
                    //* Matches @Command: Data
                    const match = /^\s*@(.+?):\s*(.+)\s*$/.exec(str);
                    
                    if(!match) return verbose.logs && print(cold(`${path}:`), str);
                    
                    const [ , Command, Data ] = match;
                    const value = readData(Data);
                    
                    if(!Events[Command.toLowerCase()])
                        return verbose.error && print(cold(`${path}:`), danger('@'+Command), value);
    
                    verbose.emit && print(cold(`${path}:`), highlight('@'+Command), value);
    
                    Events[Command.toLowerCase()](value);
                }
    
                const process = spawn(resolve(FOLDER, path), args, {
                    windowsHide: true
                });
    
                process.stdout.on('data', (data) => {
                    const str = data.toString().trim().split("\n");
                    
                    str.forEach(parse);
                });
    
                process.on('close', () => subscriber.complete());
            })
        }
    }
    
    paths.forEach(addFile);
    
    //? ----------- Server -------------
    
    const server = new Server(Functions);
    server.listen(PORT)
    print("ðŸš€  Server listening at port", highlight(PORT.toString()));
}