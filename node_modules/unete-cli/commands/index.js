const Storage = require('../storage');
const Registry = Storage('registry');
const Sock = require('unete-io/socket');
const repl = require('repl');
const net = require('net');
const readline = require('readline-sync');
const path = require('path');
const Server = require('unete-io/server');
const YAML = require('yamljs');
const https = require('https');
const fs = require('fs');
const UneteFS = require('unete-fs');

const { log, danger, info } = require('termx');
const { Observable } = require('rxjs');
const { toArray } = require('rxjs/operators');

// const _Storage = require('./storage');

try {
    var UneteEthClient = require('unete-eth/client');
    var UneteEthCredentials = Storage('unete-eth');
    var Web3 = require('./web3');
} catch (exc) {
    var UneteEthClient = null;
    var UneteEthCredentials = null;
    var Web3 = {};
}

const { encrypt, decrypt } =  require('../aes');

const REGEX_ASSIGNMENT = /^\$\.([^(]+)=(.+)$/;
const REGEX_VALUE = /^(\$\.[^(=]+)$/;
const REGEX_IS_BLOCKCHAIN_ADDRESS = /^([^@]+)@0x/;

const Commands = module.exports = {

    set (alias, url) {
        Registry.set(alias, url);
        log('Registry alias', alias.bold.magenta, 'was set to', url.bold.cyan);
    },

    unset (alias) {
        Registry.remove(alias);
        log('Registry alias', alias.bold.magenta, 'was removed');
    },

    registry () {
        let registry = Registry.data;
        
        log("unete-cli registry:".bold);

        for(const i in registry) log(
            ('  + ' + i.magenta + ': ' + registry[i].cyan).bold
        );
    },

    connect (url, program) {
        url = Registry.get(url) || url;
        var protocol;

        if(REGEX_IS_BLOCKCHAIN_ADDRESS.test(url)) protocol = "eth";
        else {
            protocol = url.substring(0, url.indexOf("://"));

            if(!protocol) {
                protocol = "http"
                url = 'http://' + url;
            }
        }

        log(`Connecting to ${url}...`.cyan.bold, '\n');
    
        (async () => {
            switch (protocol) {
                case "eth":
                    var data = {};
                    if(UneteEthCredentials.get('passphrase')) {
                        const signed = readline.keyInYNStrict('Do you want to sign your transactions?'.yellow.bold);

                        if(signed)
                            data = Web3.data(null, true);
                    }

                    var API = UneteEthClient(url, {
                        passphrase: data.passphrase,
                        address: data.address,
                        provider: program.node
                    });
                    
                    log("Connected as: ".bold.cyan + data.address.yellow.bold)

                    break;
                default:
                    var API = Sock(url);
            }
            
            let store = Storage('env-vars');
            let help = {};
            let methods;
            try {
                methods = await API.$public();
            } catch (exc) {
                if(exc.message === "xhr poll error")
                    log(danger("ðŸ’¥ Could not connect to the server."));

                process.exit(0);
            }

            const completions = plainify(methods);

            const r = repl.start({
                prompt: 'unete-cli> '.cyan.bold,
                eval: async (cmd, $, filename, cb) => {
                    cmd = cmd.trim();
                    if(cmd === "exit") process.exit(0);

                    try {

                        if(cmd === "help") {
                            try {
                                help = await API.$help();
                            } catch (exc) {
                                
                            }

                            log(`Available methods for ${url}:`.bold.cyan, helpify(methods, help, "", "", "  "));

                            return cb(null);        
                        }

                        let match = REGEX_ASSIGNMENT.exec(cmd);
                        
                        if(match) {
                            const val = await eval(`(async () => { return ${match[2]} })()`);
                            
                            $[match[1].trim()] = val;

                            store.set(match[1].trim(), val);
                            
                            cb(null, val);
                            return;
                        }

                        match = REGEX_VALUE.exec(cmd);

                        if(match) {
                            cb(null, eval(cmd));
                            return;
                        }

                        let rs = await eval('API.' + cmd);
                        
                        if(typeof rs.pipe === "function") {
                            rs = await rs.pipe(toArray()).toPromise();
                        }

                        cb(null, rs);

                    } catch (exc) {

                        if(typeof exc === "object") {
                            if(exc.message) exc = exc.message;
                            else exc = JSON.stringify(exc);
                        }

                        log(danger(exc));
                        cb();
                    }
                },
                completer: (line) => {
                    const hits = completions.filter((c) => c.startsWith(line));

                    return [hits.length ? hits : completions, line];
                }
            });

            for(let i in store.data)
                r.context[i] = store.data[i];
        })();
    },

    "export-registry" (data) {
        log("Exporting registry, use this command in the target machine:".bold);
        log("  +".bold, "unete-cli import-registry".bold.magenta, Registry._export().bold.cyan);
    },

    "import-registry" (data) {
        Registry._import(data);
        log("Registry successfully imported".cyan.bold);
        Commands.registry();
    },

    attach (url, pass) {
        let _url = url;
        url = Registry.get(url) || url;

        const socket = new net.Socket();
        const [host, port] = url.split(':');
        const password = pass || readline.question(`Please enter the log security password for ${url.cyan.bold}:`.green.bold, { hideEchoBack: true });
        const selected_color = ["green", "magenta", "cyan", "red", "yellow", "blue", "grey"][Math.floor(Math.random() * 7)];
            
        socket.connect(port, host, () => {

            socket.on('data', (chunk) => {
                const data = decrypt(chunk, password);

                process.stdout.write(`> ${_url}: `.bold[selected_color] + data);
            })

            socket.write(encrypt(password, password));
        });
    },

    async start (_module, port, program) {
        if(!program) {
            program = port;
            port = undefined;
        }

        const config = program.config? typeof program.config === "string"? YAML.load(program.config) : program.config : {};

        if(config.handler === "unete-fs") {
            return UneteFS.default(path.resolve(process.cwd(), config.folder || "."), config.port, {
                include: config.include || [],
                exclude: config.exclude || []
            });
        }

        if(!port && !config.port) throw "PORT_EXPECTED";
        if(!port) port = config.port;
        if(config.env) {
            const { env } = config;
            for(let i in env)
                process.env[i] = env[i];
        }
        
        try {
            if(!config.es6) _module = require(path.join(process.cwd(), _module || 'index.js'));
            else _module = await import(path.join(process.cwd(), _module || 'index.mjs'))
        } catch (exc) {
            log(exc);
            process.exit(0);
        }

        var https_server; // HTTPS Server
        if(config.https) {
           https_server = https.createServer({
                key : fs.readFileSync(path.resolve(process.cwd(), config.https.key)),
                cert: fs.readFileSync(path.resolve(process.cwd(), config.https.cert)),
                ca  : fs.readFileSync(path.resolve(process.cwd(), config.https.ca))
            });
        }

        let server = new Server(_module, https_server);

        if(program.log) {
            server.on('connection', (sock) => {
                sock.on('call', ({ path, args, cb }) => {
                    if(!Array.isArray(path)) return;
                    const _args = args.map((arg, i) => {
                        let type = typeof arg;

                        if(cb[i]) type = "function";

                        return (type[0].toUpperCase() + type.substring(1)).bold.magenta;
                    }).join(", ");

                    let addr = sock.request.connection.remoteAddress;

                    if(addr.indexOf("::ffff:") === 0) addr = addr.substring(7);

                    log(`${path.join('.')}(${_args.bold.magenta}`.bold.cyan + ")".bold.cyan);
                });
            });
        }
    
        (async () => {
            if(config.https)
                await https_server.listen(port);
            else
                await server.listen(port);

            log(("Microservice running at port :" + port).bold.cyan);
        })();
    },

    run (config, program) {
        program.config = config;
        config = YAML.load(config);
        return Commands.start(config.main, config.port, program);
    },

    watch (...connections) {
        connections.forEach((connection) => {
            if(typeof connection !== "string") return;
            const [url, pass] = connection.split("/");

            Commands.attach(url, pass);
        });
    },

    web3(cmd, ...args) {
        Web3[cmd] && Web3[cmd](...args);
    },

    /*storage(cmd, ...args) {
        _Storage[cmd] && _Storage[cmd](...args);
    }*/

}

function helpify (obj, help, header = "", pre = "", tabs="") {
    let str = (header && `+ ${pre + "*"}:`.bold.cyan) || "";
    
    for(let i in obj) {
        let fn = obj[i];
        let _help = help && help[i];

        if(typeof fn === "object" && !Array.isArray(fn.arguments) && !Array.isArray(fn)) str += "\n" + tabs + helpify(fn, _help, i, i + ".", tabs + "  ");
        else {
            if(fn.arguments) {
                let args = fn.arguments.map((x) => x.bold.magenta).join(', '.bold.cyan);
                
                str += `\n${tabs}${'+'.bold.cyan} ${pre.bold.cyan}${i.bold.cyan}${`(${args})`.bold.cyan}${_help? `: ${_help.description}`.bold.cyan: ""}`;
            } else {
                let args = Array.isArray(fn)? fn.map((x) => x.bold.magenta).join(', '.bold.cyan) : "...".bold.magenta;
    
                str += `\n${tabs}${'+'.bold.cyan} ${pre.bold.cyan}${i.bold.cyan}${`(${args})`.bold.cyan}`;
            }
        }
    }

    return str;
}

function plainify (obj, pre="") {
    let x = [];

    for(let i in obj) {
        let y = obj[i];

        if(typeof y === "object" && !Array.isArray(y) && !Array.isArray(y.arguments)) x = [...x, ...plainify(y, i + ".")];
        else x.push(pre + i);
    }

    return x;
}